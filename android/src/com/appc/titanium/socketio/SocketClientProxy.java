/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-Present by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.appc.titanium.socketio;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollProxy;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;
import org.appcelerator.titanium.util.TiConvert;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.util.Pair;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;

import io.socket.client.Ack;
import io.socket.client.Socket;
import io.socket.emitter.Emitter.Listener;

@Kroll.proxy(creatableInModule=TiSocketioModule.class)
public class SocketClientProxy extends KrollProxy
{
	// Standard Debugging variables
	private static final String LCAT = "SocketIOClientProxy";
	private static final boolean DBG = TiConfig.LOGD;

	private Socket socket;
	private SocketManagerProxy manager;
	private HashMap<String, HashSet<Pair<KrollFunction, Listener>>> eventHandlers;

	// Constructor
	public SocketClientProxy(Socket socket, SocketManagerProxy manager)
	{
		super();

		this.socket = socket;
		this.manager = manager;
		this.eventHandlers = new HashMap<String, HashSet<Pair<KrollFunction, Listener>>>();
	}

	// Properties
	@Kroll.getProperty
	public String getId()
	{
		return this.getConnected() ? this.socket.id() : null;
	}

	@Kroll.getProperty
	public boolean getConnected()
	{
		return this.socket.connected();
	}

	@Kroll.getProperty
	public SocketManagerProxy getIo()
	{
		return this.manager;
	}

	// Methods
	@Kroll.method
	public void open()
	{
		this.socket.open();
	}

	@Kroll.method
	public void connect()
	{
		this.socket.connect();
	}

	@Kroll.method
	public SocketClientProxy on(final String eventName, final KrollFunction callback)
	{
		Listener listener = new Listener() {
			@Override
			public void call(Object... args)
			{
				callback.call(getKrollObject(), convertArguments(args));
			}
		};
		this.socket.on(eventName, listener);
		this.storeEventHandler(eventName, callback, listener);

		return this;
	}

	@Kroll.method
	public SocketClientProxy once(String eventName, final KrollFunction callback)
	{
		Listener listener = new Listener() {
			@Override
			public void call(Object... args)
			{
				callback.call(getKrollObject(), convertArguments(args));
			}
		};
		this.socket.once(eventName, listener);
		this.storeEventHandler(eventName, callback, listener);

		return this;
	}

	@Kroll.method
	public SocketClientProxy off()
	{
		this.socket.off();
		this.removeAllEventHandlers();

		return this;
	}

	@Kroll.method
	public SocketClientProxy off(String eventName)
	{
		this.socket.off(eventName);
		this.removeEventHandler(eventName);

		return this;
	}

	@Kroll.method
	public SocketClientProxy off(String eventName, KrollFunction callback)
	{
		Listener listener = this.findListener(eventName, callback);
		if (listener != null) {
			this.socket.off(eventName, listener);
			this.removeEventHandler(eventName, callback);
		}

		return this;
	}

	@Kroll.method
	public SocketClientProxy emit(String eventName, Object... args)
	{
		KrollFunction ackCallback = null;
		ArrayList<Object> data = new ArrayList<>();

		if (args.length > 0) {
			int lastArgumentIndex = args.length - 1;

			if (args[lastArgumentIndex] instanceof KrollFunction) {
				ackCallback = (KrollFunction)args[lastArgumentIndex];
				lastArgumentIndex -= 1;
			}

			for (int i = 0; i <= lastArgumentIndex; i++) {
				data.add(this.convertAndSanitizePayload(args[i]));
			}
		}

		if (ackCallback != null) {
			final KrollFunction finalAckCallback = ackCallback;
			this.socket.emit(eventName, data.toArray(), new Ack() {
				@Override
				public void call(Object... args) {
					finalAckCallback.call(getKrollObject(), convertArguments(args));
				}
			});
		} else {
			this.socket.emit(eventName, data.toArray());
		}

		return this;
	}

	@Kroll.method
	public void close() {
		this.disconnect();
	}

	@Kroll.method
	public void disconnect() {
		this.socket.disconnect();
	}

	private Object[] convertArguments(Object[] args) {
		Object[] sanitizedArgs = new Object[args.length];

		for (int i = 0; i < args.length; i++) {
			if (args[i] instanceof Exception) {
				Exception socketException = (Exception)args[i];
				KrollDict errorDict = new KrollDict();
				errorDict.put("message", socketException.getMessage());
				sanitizedArgs[i] = errorDict;
			} else if (args[i] instanceof JSONObject) {
				JSONObject json = (JSONObject)args[i];
				try {
					sanitizedArgs[i] = new KrollDict(json);
				} catch (JSONException e) {
					Log.d(LCAT, "Failed to convert JSON object. Error: " + e.getMessage());
					sanitizedArgs[i] = null;
				}
			} else if (args[i] instanceof JSONArray) {
				JSONArray json = (JSONArray)args[i];
				sanitizedArgs[i] = KrollDict.fromJSON(json);
			} else {
				sanitizedArgs[i] = args[i];
			}
		}

		return sanitizedArgs;
	}

	private Object convertAndSanitizePayload(Object value) {
		if (value instanceof HashMap) {
			return TiConvert.toJSON((HashMap)value);
		} else if (value instanceof Object[]) {
			return TiConvert.toJSONArray((Object[])value);
		}

		return value;
	}

	private void storeEventHandler(String eventName, KrollFunction handler, Listener listener) {
		HashSet<Pair<KrollFunction, Listener>> handlers = this.eventHandlers.get(eventName);
		if (handlers == null) {
			handlers = new HashSet<Pair<KrollFunction, Listener>>();
		}
		handlers.add(new Pair<KrollFunction, Listener>(handler, listener));
		this.eventHandlers.put(eventName, handlers);
	}

	private void removeEventHandler(String eventName) {
		this.eventHandlers.remove(eventName);
	}

	private void removeEventHandler(String eventName, KrollFunction handler) {
		HashSet<Pair<KrollFunction, Listener>> handlers = this.eventHandlers.get(eventName);
		if (handlers == null) {
			handlers = new HashSet<Pair<KrollFunction, Listener>>();
		}
		for (Iterator<Pair<KrollFunction, Listener>> i = handlers.iterator(); i.hasNext();) {
			Pair<KrollFunction, Listener> element = i.next();
			if (element.first == handler) {
					i.remove();
			}
		}
	}

	private void removeAllEventHandlers() {
		this.eventHandlers.clear();
	}

	private Listener findListener(String eventName, KrollFunction callback) {
		HashSet<Pair<KrollFunction, Listener>> handlers = this.eventHandlers.get(eventName);
		if (handlers == null) {
			handlers = new HashSet<Pair<KrollFunction, Listener>>();
		}
		for (Pair<KrollFunction, Listener> handlerPair : handlers) {
			if (handlerPair.first == callback) {
				return handlerPair.second;
			}
		}

		return null;
	}
}
